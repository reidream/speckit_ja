# spec-kit フェーズ1: 仕様書作成の完全理解マップ

**作成日:** 2025年11月18日  
**学習者:** Leidream  
**学習範囲:** `/speckit.specify` コマンドの Step 1-2

---

## 📊 全体像: `/speckit.specify` の6ステップ

```
ユーザー: /speckit.specify "Add user authentication"
  ↓
┌─────────────────────────────────────────┐
│ Step 1: 番号決定 (スキャン & 計算)      │  ← 今回学習した範囲
│   - 短縮名生成: "user-auth"             │
│   - 3箇所スキャン                        │
│   - 最大番号検出: 004                    │
│   - 次の番号: 005                        │
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ Step 2: ブランチ & ファイル作成         │  ← 今回学習した範囲
│   - git checkout -b 005-user-auth       │
│   - mkdir specs/005-user-auth           │
│   - cp template → spec.md               │
│   - JSON出力                             │
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ Step 3: テンプレート読み込み           │  ← 次回学習
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ Step 4: AIが仕様書を生成                │  ← 次回学習
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ Step 5: spec.mdに書き込み               │  ← 次回学習
└─────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────┐
│ Step 6: 完了報告                         │  ← 次回学習
└─────────────────────────────────────────┘
```

---

## 🎯 Step 1: 番号決定の仕組み

### **本質 (理解度: ★★★★★)**

> **「同じ名前(short-name)のグループの中で、次の番号を自動で振る」**

**それだけ。**

---

### **理解の変遷**

#### ❌ 最初の理解 (曖昧)
```
「3つのソース(リモート/ローカル/specs/)をスキャン
最大番号を検出 → +1 → 005
Bashスクリプト実行 → JSON出力
このあたりが少しあいまい」
```

#### ✅ 最終的な理解 (本質)
```
「同じ名前の短文を新しい番号振りたいだけの話ね?
同じブランチで作業しても大丈夫だし、別ブランチでも大丈夫、
そして、今何を作業しているのかがわかるってこと?」
```

**→ 表面的な処理から「本質」を理解できた**

---

### **具体例: 番号付けの動作**

```bash
既存の状態:
  001-user-auth   ← 認証の基本実装
  002-user-auth   ← OAuth2追加
  003-user-auth   ← 2FA追加
  001-payment     ← 決済の基本実装 (別グループ)
  002-payment     ← エラー処理 (別グループ)

新規作成: "Add password reset to authentication"
  ↓
short-name: "user-auth"
  ↓
"user-auth" で検索:
  リモート: 001, 002, 003
  ローカル: 001, 002, 003
  specs/  : 001, 002, 003
  ↓
最大: 003
  ↓
次の番号: 004
  ↓
作成: 004-user-auth
```

**ポイント:** `payment` の番号は無関係 (名前が違うから)

---

### **なぜ3箇所をスキャンするか? (理解度: ★★★★★)**

| 箇所 | 理由 |
|------|------|
| **リモートブランチ** | 他のメンバーが作ったブランチを検出 |
| **ローカルブランチ** | 自分がまだプッシュしてないブランチを検出 |
| **specs/ディレクトリ** | Git上で削除したが、ファイルが残ってる番号を検出 |

**→ どこかに残ってる番号を見逃さない = 衝突を防ぐ**

---

## 🔬 Step 1の詳細: コードレベルの理解

### **関数: `check_existing_branches`**

#### **入力**
```bash
short_name="user-auth"
specs_dir="/project/specs"
```

#### **処理の流れ**

```bash
# ステップ1: リモートブランチをスキャン
git ls-remote --heads origin
  ↓ (生データ)
abc123  refs/heads/main
111222  refs/heads/001-user-auth
555666  refs/heads/002-user-auth
999000  refs/heads/001-payment
333444  refs/heads/003-user-auth
  ↓ (grep でフィルタ)
grep -E "refs/heads/[0-9]+-user-auth$"
  ↓
111222  refs/heads/001-user-auth
555666  refs/heads/002-user-auth
333444  refs/heads/003-user-auth
  ↓ (sed で番号だけ抽出)
sed 's/.*\/\([0-9]*\)-.*/\1/'
  ↓
001
002
003
  ↓
remote_branches = "001 002 003"
```

**理解のポイント (理解度: ★★★★☆)**
- `grep -E "...-${short_name}$"` で**同じ名前だけ**フィルタ
- `sed 's/.*\/\([0-9]*\)-.*/\1/'` で**番号だけ**抽出
- パイプ `|` で処理を順次つなげる

---

```bash
# ステップ2: ローカルブランチをスキャン
git branch
  ↓
  001-user-auth
  002-user-auth
* 003-user-auth
  001-payment
  main
  ↓ (grep)
grep -E "^[* ]*[0-9]+-user-auth$"
  ↓
  001-user-auth
  002-user-auth
* 003-user-auth
  ↓ (sed で先頭の記号削除)
sed 's/^[* ]*//'
  ↓
001-user-auth
002-user-auth
003-user-auth
  ↓ (sed で番号だけ)
sed 's/-.*//'
  ↓
001
002
003
  ↓
local_branches = "001 002 003"
```

---

```bash
# ステップ3: specs/ディレクトリをスキャン
find /project/specs -maxdepth 1 -type d -name "[0-9]*-user-auth"
  ↓
/project/specs/001-user-auth
/project/specs/002-user-auth
/project/specs/004-user-auth  ← ローカルにない番号を発見!
  ↓ (basename)
001-user-auth
002-user-auth
004-user-auth
  ↓ (sed)
001
002
004
  ↓
spec_dirs = "001 002 004"
```

---

```bash
# ステップ4: 最大値を計算
all_numbers = "001 002 003 001 002 003 001 002 004"
                ↑リモート   ↑ローカル  ↑specs/

max_num = 0
for num in 001 002 003 001 002 003 001 002 004:
    if num > max_num:
        max_num = num

結果: max_num = 004
次の番号: 005
```

**理解のポイント (理解度: ★★★★★)**
- 全ての番号を集めて、forループで最大値を探すだけ
- 重複は無視される (結果に影響しない)
- 欠番があっても問題ない (最大値から継続)

---

## 🛠️ Step 2: ブランチとファイル作成

### **4つの処理 (理解度: ★★★★★)**

```bash
# 処理1: Gitブランチ作成
if [ "$HAS_GIT" = true ]; then
    git checkout -b "005-user-auth"
fi

# 処理2: ディレクトリ作成
mkdir -p "specs/005-user-auth"

# 処理3: テンプレートコピー
cp ".specify/templates/spec-template.md" \
   "specs/005-user-auth/spec.md"

# 処理4: JSON出力
printf '{"BRANCH_NAME":"005-user-auth","SPEC_FILE":"/project/specs/005-user-auth/spec.md","FEATURE_NUM":"005"}\n'
```

---

### **結果として作られるもの**

#### **1. Gitブランチ**
```bash
$ git branch
  001-user-auth
  002-user-auth
  003-user-auth
  004-user-auth
* 005-user-auth  ← 新規作成され、ここに切り替わる
```

#### **2. ディレクトリ構造**
```
specs/
  ├── 001-user-auth/
  ├── 002-user-auth/
  ├── 003-user-auth/
  ├── 004-user-auth/
  └── 005-user-auth/      ← 新規作成
      └── spec.md         ← テンプレートからコピー
```

#### **3. JSON出力 (stdout)**
```json
{
  "BRANCH_NAME": "005-user-auth",
  "SPEC_FILE": "/project/specs/005-user-auth/spec.md",
  "FEATURE_NUM": "005"
}
```

**このJSONをAIエージェント(Claude)が次のステップで使う**

---

## 💡 重要な気づき

### **設計思想の理解 (理解度: ★★★★★)**

#### **番号付けの目的**
1. **機能の進化を追跡**
   ```
   001-user-auth  基本認証
   002-user-auth  OAuth2追加
   003-user-auth  2FA追加
   → 同じ機能の歴史が見える
   ```

2. **チーム並行作業**
   ```
   Aさん: 003-user-auth (認証チーム)
   Bさん: 002-payment   (決済チーム)
   Cさん: 001-dashboard (UIチーム)
   → 番号が衝突しない
   ```

3. **作業状況の可視化**
   ```bash
   $ git branch
   * 005-user-auth  ← 今ここで作業中
   → 一目で分かる
   ```

---

### **図書館メタファー (理解度: ★★★★★)**

```
📚 図書館の本棚システム

[歴史コーナー]
  001-歴史
  002-歴史
  003-歴史

[料理コーナー]
  001-料理
  002-料理

[プログラミングコーナー]
  001-プログラミング
  002-プログラミング

→ ジャンル(short-name)ごとに番号が独立
→ spec-kitも同じ仕組み
```

---

## 📝 理解度の自己評価

| 項目 | 理解度 | メモ |
|------|--------|------|
| **番号付けの本質** | ★★★★★ | 「同じ名前で連番を振る」と言語化できた |
| **3箇所スキャンの理由** | ★★★★★ | 衝突防止のため |
| **設計思想** | ★★★★★ | 図書館メタファーで完全理解 |
| **Bashコマンドの詳細** | ★★★★☆ | grep, sed, パイプの動作は理解。細かい正規表現は要復習 |
| **JSON出力の役割** | ★★★★★ | AIエージェントに渡すためのデータ |
| **実用的な使い方** | ★★★★★ | 同じ/別ブランチでの作業、追跡が可能 |

---

## 🔄 復習時のチェックポイント

### **本質の確認**
- [ ] 「同じ名前で連番を振る」と説明できるか?
- [ ] なぜ3箇所スキャンするか説明できるか?
- [ ] 図書館メタファーを自分の言葉で説明できるか?

### **技術的な確認**
- [ ] `grep -E "...-${short_name}$"` の意味は?
- [ ] `sed 's/.*\/\([0-9]*\)-.*/\1/'` の動作は?
- [ ] forループで最大値を探す処理は?

### **実践的な確認**
- [ ] 同じshort-nameで複数ブランチを作る利点は?
- [ ] チーム開発でどう役立つか?
- [ ] 欠番がある場合の動作は?

---

## 🚀 次回の学習内容

### **Step 3-6: AIによる仕様書生成**
1. テンプレート読み込み
2. AIが要件を抽出
3. 仕様書を生成
4. spec.mdに書き込み
5. 完了報告

**学習の進め方:**
- Step 1-2と同様に本質を理解
- コードレベルの詳細も追う
- 実用的なユースケースを考える

---

## 📚 参考資料

### **学習に使用したファイル**
- `.specify/scripts/bash/create-new-feature.sh`
- `.specify/scripts/bash/common.sh`
- `.claude/commands/speckit.specify.md`

### **キーワード**
- short-name
- 機能番号の自動採番
- 3箇所スキャン (リモート/ローカル/specs/)
- JSON出力
- Bashパイプライン

---

## 🎓 学習の成果

### **Before (学習前)**
```
「3つのソースをスキャン...最大番号を検出...
このあたりが少しあいまい」
```

### **After (学習後)**
```
「同じ名前の短文を新しい番号振りたいだけ。
同じブランチでも別ブランチでも大丈夫。
図書館の本棚システムと同じ。」
```

**→ 本質を理解し、自分の言葉で説明できるようになった ✅**

---

**作成者メモ:**
- このドキュメントは復習用
- 理解度の変遷を記録
- 次回学習の出発点として使用

**最終更新:** 2025年11月18日
