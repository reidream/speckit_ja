# spec-kit 学習プロセス・テンプレート

> **このドキュメントの目的**: 新しいセッションを開いたときに、どこまで学習が進んでいて、次に何をすべきかを即座に把握できるようにする

---

## 📋 プロジェクト全体像

### 最終目標
**オリジナルのplan agent作成** - spec-kitの原理を理解し、自動学習機能を持つ進化型agentを構築する

### 学習の核心アプローチ
**コマンド機能から全体を理解する** - spec-kitは7つのコマンドで全てを説明できる

```
/speckit.constitution  憲章作成
/speckit.specify       仕様書作成  ← ここが最重要
/speckit.clarify       仕様明確化
/speckit.plan          技術計画
/speckit.tasks         タスク分解
/speckit.implement     実装実行
/speckit.analyze       品質分析
/speckit.checklist     検証リスト
```

### 現在の進捗状況
- 🟢 **Phase 1**: ✅ 完了（4段階ワークフロー理解）
- 🟡 **Phase 2**: 🔄 進行中（コマンド機能の深掘り中）
- ⚪ **Phase 3-6**: 未着手

---

## 📚 利用可能なリソース

### プロジェクトファイル（参照元）
```
/mnt/project/
├── GitHub_spec-kit_からのplan_agnet_になる参照  (24KB, 338行の技術調査)
├── chat_gpt_のリサーチ_apec-kit                 (拡張機能作成の準備メモ)
└── 使い方をgemini_からyoutube_の要約            (7ステップの実践ワークフロー)
```

### 外部リソース
- GitHub: https://github.com/github/spec-kit
- ドキュメント: https://github.github.io/spec-kit/

---

## 🔄 学習プロセス - 6フェーズ

### Phase 1: 全体構造の把握 ✅
**学習方法**:
1. 3つのファイル全体を読み込む
2. spec-kitの「4段階ワークフロー」を理解
3. 「なぜこのツールが存在するのか」という哲学を把握

**理解度チェック**:
- [ ] Constitution → Specify → Plan → Tasks の流れを説明できるか？
- [ ] 各フェーズの「目的」を言えるか？
- [ ] spec-kitが解決する問題を自分の言葉で説明できるか？

**完了条件**: 
上記3つの質問に即答できる状態

---

### Phase 2: コマンド機能から全体を理解 🔄
**学習方法**:
コマンド機能の実装を読み解くことで、spec-kitの設計思想を完全に理解する

**7つのコマンドを順番に理解する**:

#### 2-1. /speckit.constitution (憲章作成)
```
役割: プロジェクトの「譲れない原則」を定義
場所: .claude/commands/speckit.constitution.md

学習ポイント:
- [ ] 憲章とは「交渉の余地がない」原則
- [ ] 全てのphaseで憲章準拠をチェック
- [ ] constitution.mdの構造
```

#### 2-2. /speckit.specify (仕様書作成) ⭐最重要
```
役割: 自然言語から機能仕様書を自動生成
場所: .claude/commands/speckit.specify.md

このコマンドが最重要な理由:
→ spec-kitの核心ロジックが全て入っている
→ 他のコマンドはこれの応用

必ず理解すべき7ステップ:

Step 1: short-name生成アルゴリズム
  - 機能説明 → 2-4語の短縮名
  - 例: "ユーザー認証追加" → "user-auth"

Step 2: 機能番号の自動採番
  - リモートブランチをスキャン
  - ローカルブランチをスキャン  
  - specsディレクトリをスキャン
  - 最大値+1を新番号に
  
  重要: git fetch --all --prune を必ず実行
  
Step 3: スクリプト実行
  .specify/scripts/bash/create-new-feature.sh --json
  → JSON形式でパスを返す
  
Step 4: spec-template.mdの読み込み
  
Step 5: 8段階の仕様生成フロー
  5-1. ユーザー説明の解析
  5-2. 主要概念の抽出（アクター、アクション、データ、制約）
  5-3. 曖昧な部分に[NEEDS CLARIFICATION]マーク（最大3つ）
  5-4. ユーザーシナリオの生成
  5-5. 機能要件の生成
  5-6. 成功基準の検証
  5-7. エンティティスキーマの生成
  5-8. 仕様書の書き込み

Step 6: 品質検証
  - 測定可能性チェック
  - 一貫性チェック
  - 完全性チェック

Step 7: handoffs（次のコマンドへの引き継ぎ）
  → /speckit.plan または /speckit.clarify
```

**Step 5-2が最重要**:
```
4つの概念を抽出する能力が全て:
  - アクター（誰が）
  - アクション（何をする）  
  - データ（何を扱う）
  - 制約（どんな条件で）

これが理解できれば、他のステップは自然に理解できる
```

#### 2-3. /speckit.clarify (仕様明確化)
```
役割: [NEEDS CLARIFICATION]の解消
場所: .claude/commands/speckit.clarify.md

学習ポイント:
- [ ] どうやって曖昧な部分を検出するか
- [ ] ユーザーへの質問生成ロジック
- [ ] 回答の仕様書への反映方法
```

#### 2-4. /speckit.plan (技術計画)
```
役割: spec.mdから技術実装計画を生成
場所: .claude/commands/speckit.plan.md

学習ポイント:
- [ ] Phase -1: 憲章コンプライアンスチェック
- [ ] Phase 0-2の段階的アプローチ
- [ ] 技術スタックの選定ロジック
- [ ] データモデルとの連携
```

#### 2-5. /speckit.tasks (タスク分解)
```
役割: plan.mdから実行可能タスクに分解
場所: .claude/commands/speckit.tasks.md

学習ポイント:
- [ ] [P]マーカー（並列実行可能）の判定
- [ ] 依存関係の自動検出
- [ ] タスクのフェーズ分類
```

#### 2-6. /speckit.implement (実装実行)
```
役割: tasks.mdを実際に実行
場所: .claude/commands/speckit.implement.md

学習ポイント:
- [ ] 前提条件チェック（check-prerequisites.sh）
- [ ] 依存関係順の実行
- [ ] 並列タスクの同時実行
- [ ] [X]マーク（完了）の自動付与
```

#### 2-7. /speckit.analyze (品質分析)
```
役割: spec/plan/tasksの一貫性分析
場所: .claude/commands/speckit.analyze.md

学習ポイント:
- [ ] 重複検出
- [ ] 曖昧さ検出
- [ ] カバレッジギャップ
- [ ] 憲章との整合性チェック
```

#### 2-8. /speckit.checklist (検証リスト)
```
役割: 「要件のためのユニットテスト」作成
場所: .claude/commands/speckit.checklist.md

重要な概念:
✅ 実装のテストではない
✅ 要件記述の品質テスト

学習ポイント:
- [ ] 要件の完全性チェック
- [ ] 要件の明確さチェック
- [ ] 測定可能性チェック
```

**完了条件**:
各コマンドについて、以下を説明できる:
- [ ] 何をするコマンドか？
- [ ] なぜこの設計なのか？
- [ ] どうやって実装されているか？
- [ ] 他のコマンドとどう連携するか？

**学習パターン（Leidreamスタイル）**:
```
❌ 表面的に「何をするか」だけ理解
✅ 「なぜその設計にしたのか？」を必ず聞く

例:
❌ 悪い質問: "specifyコマンドは何をする?"
✅ 良い質問: "なぜSpecifyとPlanを分離しているの?"

❌ 悪い質問: "short-nameを生成する"
✅ 良い質問: "なぜgit branchとspecsディレクトリの
              両方をスキャンする必要があるの?"
```

---

### Phase 3: テンプレートとスクリプトの仕組み ⚪
**学習方法**:
コマンド機能が「どうやって動くか」の裏側を理解

**3つの要素を理解**:

#### 3-1. テンプレートシステム
```
場所: .specify/templates/

spec-template.md      仕様書の雛形
plan-template.md      計画書の雛形
tasks-template.md     タスクの雛形

学習ポイント:
- [ ] YAMLフロントマター形式
- [ ] プレースホルダー置換（{SCRIPT}、__AGENT__）
- [ ] なぜMarkdownなのか？
```

#### 3-2. 自動化スクリプト
```
場所: .specify/scripts/bash/ と /powershell/

create-new-feature     機能番号の自動採番
update-agent-context   技術スタック抽出
check-prerequisites    環境検証

学習ポイント:
- [ ] なぜBashとPowerShellの両方？
- [ ] JSON出力の構造
- [ ] エラーハンドリング
```

#### 3-3. データフロー
```
ユーザー入力
  ↓
コマンドファイル(.md)読み込み
  ↓
スクリプト実行
  ↓
JSON出力
  ↓
テンプレート読み込み
  ↓
AIが埋める
  ↓
ファイル書き込み

各ステップの「なぜ」を理解する
```

**完了条件**:
「コマンドが実行されてから、ファイルが生成されるまで」の全フローを図解できる

---

### Phase 4: 自分のagent設計構想 ⚪
**学習方法**:
spec-kitの原理を応用して、独自設計を構想

**設計すべき要素**:

#### 4-1. 差別化ポイントの明確化
```
spec-kitで足りない部分:
  - 過去プロジェクトからの学習機能なし
  - メモリーが記録されるが、次回に活用されない

自分のplan agentの特徴:
  - Plan Agent → Search Agent → Memory Agent
  - 過去の成功パターンを自動学習
  - 安全なフィルタリング機能
```

#### 4-2. コマンド設計
```
既存コマンドを拡張:

/my-plan-agent.create
  → spec-kitの/speckit.plan + 過去プロジェクト検索

/my-plan-agent.learn
  → 完了したplan.mdから学習データ抽出

/my-plan-agent.search
  → 類似プロジェクトの検索

/my-plan-agent.apply
  → 学習データの安全な適用
```

#### 4-3. 実装方法の検討
```
2つのアプローチ:

Option A: .claude/commands/*.md を自作
  メリット: 既存のspec-kitと共存可能
  デメリット: スクリプトも自作必要

Option B: spec-kitをforkして拡張
  メリット: 既存のインフラ活用
  デメリット: メンテナンスコスト高
  
どちらを選ぶ？
```

**完了条件**:
「自分のplan agentのspec.md（仕様書）」を書ける状態

---

### Phase 5: プロトタイプ実装 ⚪
**学習方法**:
最小機能版を実際に作って動かす

**実装ステップ**:

#### Step 1: カスタムコマンド作成
```
.claude/commands/my-plan-agent.md を作る

内容:
---
description: 過去プロジェクトを学習するplan agent
handoffs:
  - label: 学習データ適用
    agent: my-plan-agent.apply
---

# 実行手順
1. 類似プロジェクトを検索
2. 学習データを抽出
3. 現在のplanに適用
```

#### Step 2: 実行スクリプト作成
```
.specify/scripts/bash/search-past-projects.sh

機能:
- specs/ディレクトリをスキャン
- 類似度計算（キーワードマッチ）
- JSON形式で結果返却
```

#### Step 3: 動作確認
```
Claudeで実行:
/my-plan-agent "ユーザー認証機能"

期待結果:
→ 過去の認証関連プロジェクトを検索
→ 学習データを提示
→ 現在のplanに反映
```

**完了条件**:
「hello world」レベルでいいので、自作agentが動く

---

### Phase 6: 自動学習機能の追加 ⚪
**学習方法**:
本格的な学習メカニズムを実装

**実装機能**:

#### 6-1. メモリー構造の設計
```
.specify/memory/learning/
  ├── projects.json       プロジェクト一覧
  ├── patterns.json       成功パターン
  └── warnings.json       失敗パターン

各ファイルのスキーマ設計
```

#### 6-2. 学習データの抽出
```
完了したplan.mdから:
  - 技術スタックの選択理由
  - アーキテクチャパターン
  - 回避した問題
  - 成功した工夫

抽出アルゴリズム:
  キーワードベース + LLM要約
```

#### 6-3. 安全性の確保
```
検証レイヤー:
  - 悪いデータのフィルタリング
  - 憲章との整合性チェック
  - ユーザー承認プロセス
```

#### 6-4. 適用ロジック
```
類似プロジェクトの判定:
  - ドメインの一致度
  - 技術スタックの類似度
  - 規模の近さ

学習データの反映:
  - plan.mdの該当セクションに追記
  - [LEARNED FROM: project-name] マーク
```

**完了条件**:
「2つ目のプロジェクトで、1つ目の経験が自動的に活用される」ことを実証

---

## 🔧 新しいセッションでの使い方

### セッション開始時（30秒）
```
1. このファイルを読み込む
「speckit_学習テンプレート_マスター.mdを読み込んで」

2. 現在地を確認
「Phase 2のどこまで進んでいるか教えて」

3. 今日の学習テーマを決める
「Phase 2-2の/speckit.specifyコマンドの
 Step 5（8段階の仕様生成フロー）を深掘りしたい」
```

### 学習中
```
理解したことをリアルタイムでメモ:
「今理解したことを、このテンプレートの
 Phase 2-2に追記して」

疑問点も即座に記録:
「『なぜshort-nameを生成するのか』を
 疑問リストに追加して」
```

### セッション終了時
```
1. 進捗記録を更新
「今日の学習内容をまとめて、
 Phase 2の完了チェックリストを更新して」

2. 次回のスタート地点を明記
「次回は Phase 2-3の/speckit.clarifyから
 始めるべきと記録して」
```

---

## 📝 Phase 2 の学習記録

### 現在の理解度

#### /speckit.constitution
- [ ] 未着手

#### /speckit.specify ⭐
- [ ] Step 1: short-name生成
- [ ] Step 2: 機能番号の自動採番
- [ ] Step 3: スクリプト実行
- [ ] Step 4: テンプレート読み込み
- [ ] Step 5: 8段階の仕様生成フロー
- [ ] Step 6: 品質検証
- [ ] Step 7: handoffs

**Step 5の詳細**:
- [ ] 5-1. ユーザー説明の解析
- [ ] 5-2. 主要概念の抽出（最重要）
- [ ] 5-3. [NEEDS CLARIFICATION]マーク
- [ ] 5-4. ユーザーシナリオの生成
- [ ] 5-5. 機能要件の生成
- [ ] 5-6. 成功基準の検証
- [ ] 5-7. エンティティスキーマの生成
- [ ] 5-8. 仕様書の書き込み

#### /speckit.clarify
- [ ] 未着手

#### /speckit.plan
- [ ] 未着手

#### /speckit.tasks
- [ ] 未着手

#### /speckit.implement
- [ ] 未着手

#### /speckit.analyze
- [ ] 未着手

#### /speckit.checklist
- [ ] 未着手

### 今日の質問リスト
1. 
2. 
3. 

### 次回の学習テーマ
- 

---

## 💡 学習Tips

### 効果的な質問の仕方
```
❌ 悪い: "specifyコマンドって何?"
✅ 良い: "なぜSpecifyとPlanを分離しているの?"

❌ 悪い: "short-nameを生成する"
✅ 良い: "なぜgit branchとspecsディレクトリの
         両方をスキャンする必要があるの?"

❌ 悪い: "テンプレートの説明して"
✅ 良い: "なぜテンプレートはMarkdown形式なの?
         JSONやYAMLではダメな理由は?"
```

### Leidreamの学習パターン
```
1. 層を積み上げる
   表面 → 実装 → 設計思想

2. 「Why」への執着
   「どう動くか」より「なぜその設計か」

3. 全体フローの重視
   コード断片ではなく、データの流れ

4. 抽象化と具体化の往復
   原理 → 具体例 → 原理に戻る
```

### 注意事項
```
✅ このファイルは「学習方法」のテンプレート
✅ 学習内容は別ファイル（phases[n]--name.md）に記録
✅ メタ認知を大切に（どう学んでいるかを意識）
✅ コマンド機能が全ての起点
```
