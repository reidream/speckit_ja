---
description: 自然言語の機能説明から機能仕様書を作成します（日本語対応）
handoffs:
  - label: 技術計画を作成
    agent: planagent.plan
    prompt: この仕様書から技術計画を作成してください。使用技術は...
  - label: 仕様を明確化
    agent: planagent.clarify
    prompt: 仕様書の要件を明確化してください
    send: true
---

## ユーザー入力

```text
$ARGUMENTS
```

このコマンドを実行する前に、必ずユーザー入力を確認してください（空でない場合）。

## 概要

ユーザーが `/planagent.specify` の後に入力したテキストが機能説明です。`$ARGUMENTS` が文字通り表示されている場合でも、この会話で利用可能と仮定してください。ユーザーが空のコマンドを提供した場合を除き、再度入力を求めないでください。

機能説明に基づいて、以下を実行します:

### 1. 簡潔な短縮名を生成（2-4語）

機能説明を分析し、最も意味のあるキーワードを抽出:
- アクション-名詞形式を使用（例: "add-user-auth", "fix-payment-bug"）
- 技術用語や略語はそのまま保持（OAuth2, API, JWT など）
- 一目で機能を理解できる簡潔さを保つ

**例:**
- "ユーザー認証を追加したい" → "user-auth"
- "APIにOAuth2統合を実装" → "oauth2-api-integration"
- "分析用ダッシュボードを作成" → "analytics-dashboard"
- "決済処理のタイムアウトバグを修正" → "fix-payment-timeout"

### 2. 既存ブランチを確認してから新規作成

a. すべてのリモートブランチを取得して最新情報を確保:
```bash
git fetch --all --prune
```

b. short-name に対して、すべてのソースから最も高い機能番号を見つける:
- リモートブランチ: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
- ローカルブランチ: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
- 仕様ディレクトリ: `plans/[0-9]+-<short-name>` にマッチするディレクトリを確認

c. 次に利用可能な番号を決定:
- すべてのソースから番号を抽出
- 最大番号 N を見つける
- 新しいブランチ番号には N+1 を使用

d. 計算された番号と short-name を使ってスクリプトを実行:
```bash
.planagent/scripts/bash/create-new-plan.sh --json --number N+1 --short-name "your-short-name" "$ARGUMENTS"
```

**重要:**
- 3つのソース（リモートブランチ、ローカルブランチ、plansディレクトリ）すべてを確認
- 正確な short-name パターンに一致するブランチ/ディレクトリのみをマッチ
- この short-name で既存のブランチ/ディレクトリが見つからない場合は、番号1から開始
- このスクリプトは機能ごとに一度だけ実行する
- JSON出力がターミナルに提供される - 常にそれを参照して必要な情報を取得
- JSON出力には BRANCH_NAME と SPEC_FILE のパスが含まれる

### 3. テンプレートの読み込み

`.planagent/templates/spec-template.md` を読み込んで、必須セクションを理解します。

### 4. 実行フロー

1. **入力から機能説明を解析**
   - 空の場合: エラー「機能説明が提供されていません」

2. **説明から主要概念を抽出**
   - 特定: アクター、アクション、データ、制約

3. **不明確な点について:**
   - コンテキストと業界標準に基づいて情報に基づいた推測を行う
   - 以下の場合のみ [要明確化: 具体的な質問] でマーク:
     * 選択が機能範囲またはユーザー体験に大きく影響する
     * 異なる意味を持つ複数の妥当な解釈が存在する
     * 妥当なデフォルトが存在しない
   - **制限: [要明確化] マーカーは最大3つまで**
   - 優先順位: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術詳細

4. **ユーザーシナリオとテストセクションを記入**
   - 明確なユーザーフローがない場合: エラー「ユーザーシナリオを判断できません」

5. **機能要件を生成**
   - 各要件はテスト可能でなければならない
   - 未指定の詳細には妥当なデフォルトを使用（前提条件セクションに記録）

6. **成功基準を定義**
   - 測定可能で技術に依存しない成果を作成
   - 定量的指標と定性的指標の両方を含める

7. **主要エンティティを特定**（データが含まれる場合）

8. **戻り値**: SUCCESS（仕様は計画の準備完了）

### 5. 仕様書の作成

SPEC_FILE にテンプレート構造を使用して仕様書を書き込みます。セクションの順序と見出しを保持しながら、プレースホルダーを機能説明から導出された具体的な詳細に置き換えます。

### 6. 仕様書品質検証

仕様書を作成した後、品質基準に対して検証します:

a. **仕様品質チェックリストを作成**: `FEATURE_DIR/checklists/requirements.md` にチェックリストファイルを生成

b. **検証チェックを実行**: 各チェックリスト項目に対して仕様書をレビュー

c. **検証結果の処理**:
   - すべての項目が合格: チェックリストを完了としてマークし、ステップ7に進む
   - 項目が不合格: 問題をリストアップし、仕様書を更新し、再検証（最大3回）
   - [要明確化] マーカーが残っている: ユーザーに質問（最大3つ）

### 7. 完了報告

ブランチ名、仕様ファイルパス、チェックリスト結果、および次のフェーズ（`/planagent.clarify` または `/planagent.plan`）の準備状況を報告します。

**注:** スクリプトは書き込み前に新しいブランチを作成してチェックアウトし、仕様ファイルを初期化します。

## 一般ガイドライン

### クイックガイドライン

- **何を**ユーザーが必要としているか、**なぜ**必要なのかに焦点を当てる
- **どのように**実装するかは避ける（技術スタック、API、コード構造なし）
- ビジネス関係者向けに記述し、開発者向けではない
- 仕様書に埋め込まれたチェックリストは作成しない（別のコマンドで作成）

### セクション要件

- **必須セクション**: すべての機能で完了必須
- **オプションセクション**: 機能に関連する場合のみ含める
- セクションが該当しない場合は、完全に削除（「N/A」として残さない）

### AI生成のための指針

ユーザープロンプトからこの仕様書を作成する場合:

1. **情報に基づいた推測を行う**: コンテキスト、業界標準、一般的なパターンを使用してギャップを埋める
2. **前提条件を文書化**: 妥当なデフォルトを前提条件セクションに記録
3. **明確化を制限**: 最大3つの [要明確化] マーカー
4. **明確化の優先順位**: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術詳細
5. **テスターのように考える**: すべての曖昧な要件は「テスト可能で明確」チェックリスト項目で不合格になるべき

### 成功基準のガイドライン

成功基準は以下でなければなりません:

1. **測定可能**: 具体的な指標を含む（時間、パーセンテージ、カウント、レート）
2. **技術に依存しない**: フレームワーク、言語、データベース、ツールへの言及なし
3. **ユーザー中心**: システム内部ではなく、ユーザー/ビジネスの視点から成果を記述
4. **検証可能**: 実装の詳細を知らなくてもテスト/検証可能

**良い例:**

- "ユーザーは3分以内にチェックアウトを完了できる"
- "システムは10,000の同時ユーザーをサポートする"
- "検索の95%が1秒未満で結果を返す"
- "タスク完了率が40%向上する"

**悪い例（実装重視）:**

- "APIレスポンスタイムが200ms未満" → 「ユーザーは即座に結果を見る」を使用
- "データベースは1000 TPSを処理できる" → ユーザー向け指標を使用
- "Reactコンポーネントが効率的にレンダリング" → フレームワーク固有
- "Redisキャッシュヒット率が80%以上" → 技術固有
